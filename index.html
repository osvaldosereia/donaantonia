import React, { useMemo, useState } from "react";

/*
  App Gerador de Prompts para Imagens de Carrossel
  — Etapas: (1) nº de cards • (2) layout + paleta • (3) textos • (4) prompts com copiar
  — Requisitos atendidos:
    ✓ 6–12 cards
    ✓ 3 tipos de layout por card
    ✓ 3 paletas (cada uma com 4 variações harmônicas); variação aleatória por card
    ✓ Garante texto exatamente como digitado (instruções explícitas no prompt)
    ✓ Botão "Copiar" por card
  — Stack: React + Tailwind (shadcn/ui opcional).
*/

// Paletas com 4 variações cada (cores apenas como referência textual para o prompt)
const PALETTES = [
  {
    id: "classica-escura",
    name: "Clássica Escura",
    variations: [
      { bg: "bordô profundo", primary: "laranja queimado", secondary: "bege claro", accent: "vermelho escuro" },
      { bg: "marrom café", primary: "vermelho vibrante", secondary: "marfim", accent: "âmbar" },
      { bg: "grafite", primary: "coral", secondary: "areia clara", accent: "cobre" },
      { bg: "azul petróleo", primary: "laranja vivo", secondary: "off-white", accent: "dourado fosco" },
    ],
  },
  {
    id: "pastel-moderno",
    name: "Pastel Moderno",
    variations: [
      { bg: "creme", primary: "salmon pastel", secondary: "cinza azulado claro", accent: "pêssego" },
      { bg: "lavanda pálido", primary: "azul bebê", secondary: "cinza quente", accent: "menta" },
      { bg: "pêssego suave", primary: "magenta pastel", secondary: "marfim", accent: "lilás" },
      { bg: "menta suave", primary: "turquesa", secondary: "cinza perolado", accent: "amarelo manteiga" },
    ],
  },
  {
    id: "alto-contraste",
    name: "Alto Contraste",
    variations: [
      { bg: "preto profundo", primary: "branco", secondary: "cinza claro", accent: "amarelo vívido" },
      { bg: "antracito", primary: "ciano elétrico", secondary: "branco sujo", accent: "magenta vivo" },
      { bg: "marinho", primary: "branco puro", secondary: "cinza gelo", accent: "laranja neon" },
      { bg: "ameixa escura", primary: "marfim", secondary: "cinza frio", accent: "verde-lima" },
    ],
  },
];

const LAYOUTS = [
  {
    id: "imagem-fundo",
    name: "1) Imagem grande (fundo)",
    description:
      "Imagem de fundo ocupando 100%, título e subtítulo sobrepostos com contraste e legibilidade (blur/overlay se necessário).",
  },
  {
    id: "imagem-centro",
    name: "2) Imagem no centro",
    description:
      "Imagem central destacada; título na parte superior; subtítulo + texto na parte inferior, com margens generosas.",
  },
  {
    id: "sem-imagem",
    name: "3) Sem imagem",
    description: "Sem foto; composição tipográfica centralizada, foco em título e texto, ritmo e respiro editorial.",
  },
];

function Stepper({ step, setStep }: { step: number; setStep: (n: number) => void }) {
  const steps = [
    { id: 1, label: "Nº de cards" },
    { id: 2, label: "Layout & Paleta" },
    { id: 3, label: "Textos" },
    { id: 4, label: "Prompts" },
  ];
  return (
    <div className="flex items-center justify-center gap-2 mb-6 select-none">
      {steps.map((s, i) => (
        <React.Fragment key={s.id}>
          <button
            onClick={() => setStep(s.id)}
            className={`px-3 py-2 rounded-xl text-sm font-semibold shadow-sm transition ${
              step === s.id ? "bg-black text-white" : "bg-zinc-100 hover:bg-zinc-200"
            }`}
          >
            {s.id}. {s.label}
          </button>
          {i < steps.length - 1 && <div className="w-6 h-[2px] bg-zinc-200" />}
        </React.Fragment>
      ))}
    </div>
  );
}

export default function PromptCarouselGenerator() {
  const [step, setStep] = useState(1);
  const [cardCount, setCardCount] = useState(6);
  const [paletteId, setPaletteId] = useState(PALETTES[0].id);
  const [layouts, setLayouts] = useState<string[]>(() => Array.from({ length: 12 }, () => LAYOUTS[0].id));
  const [texts, setTexts] = useState(
    () => Array.from({ length: 12 }, () => ({ title: "", subtitle: "", body: "" }))
  );

  // Limitar visualizações/edição ao total escolhido
  const cards = useMemo(() => Array.from({ length: cardCount }, (_, i) => i), [cardCount]);
  const palette = useMemo(() => PALETTES.find((p) => p.id === paletteId)!, [paletteId]);

  function setLayoutForAll(id: string) {
    const next = [...layouts];
    for (let i = 0; i < cardCount; i++) next[i] = id;
    setLayouts(next);
  }

  function randomVariationIndex(i: number) {
    // Determinístico por índice para estabilidade da UI: pseudo-aleatório baseado no índice
    // (evita mudar a cada render). Ainda assim "parece" aleatório ao usuário.
    const seed = (i + 1) * 9301 + 49297;
    return seed % palette.variations.length;
  }

  function copy(text: string) {
    navigator.clipboard.writeText(text);
  }

  function renderLayoutRadio(i: number) {
    return (
      <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
        {LAYOUTS.map((l) => (
          <label key={l.id} className={`border rounded-2xl p-4 cursor-pointer transition ${
            layouts[i] === l.id ? "border-black shadow" : "border-zinc-200 hover:border-zinc-300"
          }`}>
            <div className="flex items-start gap-2">
              <input
                type="radio"
                name={`layout-${i}`}
                checked={layouts[i] === l.id}
                onChange={() => {
                  const next = [...layouts];
                  next[i] = l.id;
                  setLayouts(next);
                }}
                className="mt-1"
              />
              <div>
                <div className="font-semibold">{l.name}</div>
                <div className="text-sm text-zinc-600">{l.description}</div>
              </div>
            </div>
          </label>
        ))}
      </div>
    );
  }

  function renderTexts(i: number) {
    const t = texts[i];
    function update(part: "title" | "subtitle" | "body", value: string) {
      const next = [...texts];
      next[i] = { ...next[i], [part]: value };
      setTexts(next);
    }
    return (
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="col-span-1 md:col-span-1">
          <label className="text-sm font-semibold">Título</label>
          <textarea
            value={t.title}
            onChange={(e) => update("title", e.target.value)}
            placeholder="Digite o título exatamente como quer na arte"
            className="mt-1 w-full h-24 rounded-xl border border-zinc-300 p-3 focus:outline-none focus:ring-2 focus:ring-black"
          />
        </div>
        <div className="col-span-1 md:col-span-1">
          <label className="text-sm font-semibold">Subtítulo</label>
          <textarea
            value={t.subtitle}
            onChange={(e) => update("subtitle", e.target.value)}
            placeholder="Digite o subtítulo exatamente como quer na arte"
            className="mt-1 w-full h-24 rounded-xl border border-zinc-300 p-3 focus:outline-none focus:ring-2 focus:ring-black"
          />
        </div>
        <div className="col-span-1 md:col-span-1">
          <label className="text-sm font-semibold">Texto do card</label>
          <textarea
            value={t.body}
            onChange={(e) => update("body", e.target.value)}
            placeholder="Texto/legenda do card (opcional conforme layout)"
            className="mt-1 w-full h-24 rounded-xl border border-zinc-300 p-3 focus:outline-none focus:ring-2 focus:ring-black"
          />
        </div>
      </div>
    );
  }

  function makePrompt(i: number) {
    const v = palette.variations[randomVariationIndex(i)];
    const layoutId = layouts[i];
    const t = texts[i];

    const commonHeader = `Gere uma imagem de carrossel do Instagram, proporção 4:5 (1080x1350px).\n` +
      `Use paleta "${palette.name}" (variação específica deste card): fundo ${v.bg}, cor primária ${v.primary}, ` +
      `cor secundária ${v.secondary}, cor de destaque ${v.accent}.\n` +
      `Mantenha estilo gráfico limpo, editorial, com hierarquia tipográfica e respiro.\n` +
      `GARANTA que os textos sejam renderizados EXATAMENTE como fornecidos (acentos, caixa, pontuação e quebras).\n` +
      `NÃO corrija, NÃO traduza, NÃO reescreva. Não adicionar aspas ao redor do texto do usuário.`;

    const exactTexts = `\n\nTEXTOS A IMPRIMIR (SEM ALTERAÇÕES):\n` +
      `TÍTULO:\n${t.title || ""}\n\nSUBTÍTULO:\n${t.subtitle || ""}\n\nTEXTO DO CARD:\n${t.body || ""}`;

    let layoutBlock = "";
    if (layoutId === "imagem-fundo") {
      layoutBlock = `\n\nLAYOUT: IMAGEM GRANDE (FUND0)\n` +
        `- Imagem de fundo ocupando 100% da área.\n` +
        `- Aplique overlay sutil (ou blur local) para legibilidade do título/subtítulo.\n` +
        `- Título em CAIXA ALTA na área superior ou central, com alto contraste.\n` +
        `- Subtítulo/legenda em corpo menor, posicionado abaixo do título.\n` +
        `- Elementos de rodapé discretos (ex.: número do card, logotipo).`;
    } else if (layoutId === "imagem-centro") {
      layoutBlock = `\n\nLAYOUT: IMAGEM NO CENTRO\n` +
        `- Imagem central com bordas suaves, sombra leve ou moldura mínima.\n` +
        `- Título na parte SUPERIOR do card.\n` +
        `- Subtítulo e texto na PARTE INFERIOR, com bom espaçamento e leitura confortável.`;
    } else {
      layoutBlock = `\n\nLAYOUT: SEM IMAGEM\n` +
        `- Nenhuma fotografia/ilustração.\n` +
        `- Composição tipográfica centralizada.\n` +
        `- Foque em ritmo visual e contraste entre título, subtítulo e texto.`;
    }

    const typographicRules = `\n\nREGRAS TIPOGRÁFICAS\n` +
      `- Título: fonte moderna, condensada e em CAIXA ALTA (quando escrito assim pelo usuário), peso forte.\n` +
      `- Subtítulo: menor, cor secundária, alta legibilidade.\n` +
      `- Texto: corpo regular e espaçamento confortável.\n` +
      `- Alinhamento e hierarquia devem obedecer ao layout escolhido.`;

    const finishingRules = `\n\nACABAMENTO\n` +
      `- Design minimalista, sem poluição; consistência com o restante do carrossel.\n` +
      `- Não inserir marcas d'água ou conteúdos além do fornecido.\n` +
      `- Exportar em alta resolução (1080x1350).`;

    return commonHeader + layoutBlock + typographicRules + finishingRules + exactTexts;
  }

  const prompts = useMemo(() => cards.map((i) => makePrompt(i)), [cards, layouts, texts, palette]);

  return (
    <div className="min-h-screen w-full bg-white text-zinc-900 p-6 md:p-10">
      <div className="max-w-6xl mx-auto">
        <h1 className="text-2xl md:text-4xl font-extrabold tracking-tight">App Gerador de Prompts para Carrossel</h1>
        <p className="mt-2 text-zinc-600">Quatro etapas simples. No final, copie os prompts por card. Sem rodeios.</p>

        <Stepper step={step} setStep={setStep} />

        {/* ETAPA 1 – Nº de cards */}
        {step === 1 && (
          <div className="bg-zinc-50 border border-zinc-200 rounded-2xl p-6 space-y-4">
            <div className="flex items-center gap-3">
              <label className="font-semibold">Quantos cards?</label>
              <select
                value={cardCount}
                onChange={(e) => setCardCount(parseInt(e.target.value))}
                className="border border-zinc-300 rounded-xl px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black"
              >
                {Array.from({ length: 7 }, (_, i) => 6 + i).map((n) => (
                  <option key={n} value={n}>
                    {n}
                  </option>
                ))}
              </select>
            </div>
            <div className="flex justify-between">
              <button onClick={() => setStep(2)} className="px-4 py-2 rounded-xl bg-black text-white font-semibold">
                Próximo: Layout & Paleta
              </button>
            </div>
          </div>
        )}

        {/* ETAPA 2 – Layouts por card + Paleta global */}
        {step === 2 && (
          <div className="space-y-6">
            <div className="bg-zinc-50 border border-zinc-200 rounded-2xl p-6">
              <div className="flex items-center justify-between flex-wrap gap-3">
                <div>
                  <div className="font-semibold">Paleta do carrossel</div>
                  <div className="text-sm text-zinc-600">A variação será sorteada automaticamente em cada card.</div>
                </div>
                <select
                  value={paletteId}
                  onChange={(e) => setPaletteId(e.target.value)}
                  className="border border-zinc-300 rounded-xl px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black"
                >
                  {PALETTES.map((p) => (
                    <option key={p.id} value={p.id}>
                      {p.name}
                    </option>
                  ))}
                </select>
              </div>
              <div className="mt-4 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-3">
                {PALETTES.find((p) => p.id === paletteId)!.variations.map((v, idx) => (
                  <div key={idx} className="border border-zinc-200 rounded-2xl p-4">
                    <div className="text-sm font-semibold">Variação {idx + 1}</div>
                    <div className="text-xs text-zinc-600 leading-6">
                      Fundo: {v.bg}<br />Primária: {v.primary}<br />Secundária: {v.secondary}<br />Destaque: {v.accent}
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="bg-zinc-50 border border-zinc-200 rounded-2xl p-6 space-y-6">
              <div className="flex items-center justify-between gap-3">
                <div>
                  <div className="font-semibold">Layout por card</div>
                  <div className="text-sm text-zinc-600">Escolha um layout para cada card. Se preferir, aplique um único layout a todos.</div>
                </div>
                <div className="flex gap-2">
                  {LAYOUTS.map((l) => (
                    <button key={l.id} onClick={() => setLayoutForAll(l.id)} className="px-3 py-2 rounded-xl border border-zinc-300 hover:bg-zinc-100">
                      Aplicar "{l.name}" a todos
                    </button>
                  ))}
                </div>
              </div>

              <div className="space-y-6">
                {cards.map((i) => (
                  <div key={i} className="border border-zinc-200 rounded-2xl p-4">
                    <div className="flex items-center justify-between mb-3">
                      <div className="font-semibold">Card {i + 1}</div>
                      <div className="text-xs text-zinc-500">Variação de paleta aplicada: #{randomVariationIndex(i) + 1}</div>
                    </div>
                    {renderLayoutRadio(i)}
                  </div>
                ))}
              </div>

              <div className="flex justify-between">
                <button onClick={() => setStep(1)} className="px-4 py-2 rounded-xl border border-zinc-300">Voltar</button>
                <button onClick={() => setStep(3)} className="px-4 py-2 rounded-xl bg-black text-white font-semibold">Próximo: Textos</button>
              </div>
            </div>
          </div>
        )}

        {/* ETAPA 3 – Textos */}
        {step === 3 && (
          <div className="bg-zinc-50 border border-zinc-200 rounded-2xl p-6 space-y-6">
            <div>
              <div className="font-semibold">Escreva os textos de cada card</div>
              <div className="text-sm text-zinc-600">O que você digitar será impresso na arte exatamente da mesma forma. Se quiser quebras de linha, digite-as aqui.</div>
            </div>
            <div className="space-y-6">
              {cards.map((i) => (
                <div key={i} className="border border-zinc-200 rounded-2xl p-4 space-y-4">
                  <div className="font-semibold">Card {i + 1}</div>
                  {renderTexts(i)}
                </div>
              ))}
            </div>
            <div className="flex justify-between">
              <button onClick={() => setStep(2)} className="px-4 py-2 rounded-xl border border-zinc-300">Voltar</button>
              <button onClick={() => setStep(4)} className="px-4 py-2 rounded-xl bg-black text-white font-semibold">Gerar Prompts</button>
            </div>
          </div>
        )}

        {/* ETAPA 4 – Prompts com copiar */}
        {step === 4 && (
          <div className="space-y-6">
            <div className="bg-zinc-50 border border-zinc-200 rounded-2xl p-6">
              <div className="font-semibold">Prompts prontos</div>
              <div className="text-sm text-zinc-600">Cada bloco é um prompt para um card. Clique em "Copiar" para colar onde preferir.</div>
            </div>

            {cards.map((i) => (
              <div key={i} className="border border-zinc-200 rounded-2xl overflow-hidden">
                <div className="flex items-center justify-between bg-zinc-50 px-4 py-3">
                  <div className="font-semibold">Card {i + 1} — Layout: {LAYOUTS.find((l) => l.id === layouts[i])!.name}</div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-zinc-500">Paleta: {palette.name} · Variação #{randomVariationIndex(i) + 1}</span>
                    <button
                      onClick={() => copy(prompts[i])}
                      className="px-3 py-1.5 rounded-lg bg-black text-white text-sm font-semibold"
                    >
                      Copiar
                    </button>
                  </div>
                </div>
                <textarea
                  readOnly
                  value={prompts[i]}
                  className="w-full h-64 p-4 font-mono text-sm border-0 focus:outline-none"
                />
              </div>
            ))}

            <div className="flex justify-between">
              <button onClick={() => setStep(3)} className="px-4 py-2 rounded-xl border border-zinc-300">Voltar</button>
              <button onClick={() => setStep(1)} className="px-4 py-2 rounded-xl bg-zinc-900 text-white font-semibold">Recomeçar</button>
            </div>
          </div>
        )}

        {/* Rodapé */}
        <div className="mt-10 text-xs text-zinc-500">
          Dica: Se você quer travar exatamente o case (maiúsculas/minúsculas), digite aqui do jeito que deseja. O prompt já força a impressão fiel.
        </div>
      </div>
    </div>
  );
}
